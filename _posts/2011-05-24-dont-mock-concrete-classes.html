---
layout: post
title: Don't Mock Concrete Classes
categories: []
tags:
- levelup
- php
- programming
- unittesting
status: publish
type: post
published: true
meta:
  _searchme: '1'
  _original_post_id: ''
  _original_import_author: Steve Shogren
---
<p>(They have thin skin)</p><p>I have been reading <a href="http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1303935530&amp;sr=8-1" target="_blank">G.O.O.S.</a> and honestly, much of it has been just a reiteration. Until chapter 20, that is. I get to the section Don't Mock Concrete Classes, and it clicks. <p /> Mocking concrete classes used to be my bread and butter. Almost every unit test I wrote for the last year had several mocked concrete implementations, to pass in as dependencies of the system under test. <p />What do I mean by that? Imagine a class that takes one dependency through the constructor like this:</p><p><code>class Velocity {&nbsp; public function __construct (PayoffCalc $PayoffCalc)&nbsp; {&nbsp; &nbsp; &nbsp; $this-&gt;_PayoffCalc&nbsp; = $PayoffCalc;&nbsp; }&nbsp; public function toFloat()&nbsp; {&nbsp; &nbsp; &nbsp; $paymentPerDay = $this-&gt;_PayoffCalc-&gt;getPaymentPerDay(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $this-&gt;_calculate($paymentPerDay);&nbsp; }}</code><p />Would have a test driving it, looking like this:<br /><code>public function test_velocity_validDailyPayment() {&nbsp;&nbsp;&nbsp; $paymentPerDay = 3;&nbsp;&nbsp;&nbsp; $expectedVelocity = 1392;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //Mock PayoffCalc-&gt;getPaymentPerDay() to return 3&nbsp;&nbsp;&nbsp; $PayoffCalc = $this-&gt;getMock('PayoffCalc', array('getPaymentPerDay')); &nbsp;&nbsp;&nbsp; $PayoffCalc-&gt;expects($this-&gt;once())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;method('getPaymentPerDay')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;will($this-&gt;returnValue($paymentPerDay));&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; $Velocity = new Velocity($PayoffCalc);&nbsp;&nbsp;&nbsp; $this-&gt;assertEquals($expectedVelocity, $Velocity-&gt;toFloat()); }</code><p />For several months now, writing unit tests this way has become increasingly irritating to me, for several reasons. First off, notice how phpunit does a mock? With a string for the classname and the method to mock. Obviously, in small scale this duplication is manageable, but imagine for a second thousands of unit tests all mocking this way, and you will realize it gets out of hand fast. More than once in the last year I have set out to refactor a classname or method signature, to have dozens of failing unit tests, because they all mock the <em>string</em> of the old name. <p /> Secondly, and more importantly, I find this to be brittle because you are locking yourself into an implementation of the class you need mocked. What if I wanted to move that getPaymentPerDay to a different class? Or I changed that version of getPaymentPerDay to getPaymentPerMonth? I would have to traipse through every one of those brittle mocks and rewrite their duplicated, crystalline structure. <p /> Stupid.<p />My inner frustration was so great as to cause me to start thinking up all sorts of mad ways to get around this issue. Store the code needed to build that mock as text on the class itself, to be parsed and executed on the fly? Check. Create massive hierarchical testing libraries to build the mocks? Check. And all these did was mask the real issue. <strong>I was mocking the concrete implementation.</strong><p /> So, what would mocking the interface be? Well, PayoffCalc actually has two public methods: getPayoffDate() and getPaymentPerDay(). The Velocity class only needs getPaymentPerDay(), but by mocking the concrete class, we are forcing it to depend on the <strong>whole</strong> (undefined) interface of PayoffCalc. Velocity does not need getPayoffDate(), but it is in the interface we give it (in the form of the concrete PayoffCalc). <p /> Whoa. Sounds like <a href="http://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank">ISP</a>. Written about by Bob Martin. Fifteen years ago. *Forehead smack*<p />I make an interface for this concept of PaymentPerDayRetriever, for lack of a better <a href="http://martinfowler.com/bliki/RoleInterface.html" target="_blank">Role</a>. <br /> <code>interface PaymentPerDayRetriever {&nbsp;&nbsp;&nbsp; public function getPaymentPerDay();}</code><p />Then use the interface in the test: <br /><code>public function test_velocity_validDailyPayment() {&nbsp;&nbsp;&nbsp; $paymentPerDay = 3;&nbsp;&nbsp;&nbsp; $expectedVelocity = 1392; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //Mock PayoffCalc-&gt;getPaymentPerDay() to return 3&nbsp;&nbsp;&nbsp; $PayoffCalc = $this-&gt;getMock('PaymentPerDayRetriever');&nbsp;&nbsp;&nbsp; $PayoffCalc-&gt;expects($this-&gt;any())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;method('getPaymentPerDay') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;will($this-&gt;returnValue($paymentPerDay));&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; $Velocity = new Velocity($PayoffCalc);&nbsp;&nbsp;&nbsp; $this-&gt;assertEquals($expectedVelocity, $Velocity-&gt;toFloat());}</code><p />By mocking the interface, I have freed my Velocity class from knowing about the rest of the old PayoffCalc interface, and when I realize later that my PayoffCalc really is doing two totally separate things, I can just move the PaymentPerDayRetriever interface to getPaymentPerDay's new home (probably on the PaymentRepository, not shown here). <p /> While this example only used one method per interface, in reality, it would have all the methods necessary to complete that aspect of the class.<p />Fascinating.</p>
